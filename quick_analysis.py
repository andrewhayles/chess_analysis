import pandas as pd
from scipy.stats import linregress
import matplotlib.pyplot as plt
import seaborn as sns
import os
import sys

# ==============================================================================
# --- Configuration ---
# ==============================================================================
# This script can be run at any time to check the progress of the main analysis.
# Make sure these file paths point to the same files used by your main script.

# --- File Paths ---
GRANULAR_LOG_PATH = "granular_analysis_log.csv"
ENGINES_CSV_PATH = "real_engines.csv"
# The graph generated by this script will have a unique name.
OUTPUT_GRAPH_PATH = "live_progress_graph.png"

# --- Player Name ---
# This should match the PLAYER_NAME_IN_PGN from your main script.
PLAYER_NAME = "Desjardins373"

# --- *** NEW: Engines to Exclude *** ---
# Add the names of any engines you want to exclude from the analysis and graph.
# For example, to exclude maia_1100 and maia_1900, you would use:
# ENGINES_TO_EXCLUDE = ["maia_1100", "maia_1900"]
ENGINES_TO_EXCLUDE = []


# ==============================================================================
# --- Core Logic ---
# ==============================================================================

def analyze_and_graph():
    """
    Reads the granular analysis log, calculates the current overall rating estimate,
    and generates a graph visualizing the results.
    """
    print("--- Live Analysis Visualizer ---")

    # --- 1. Check for necessary files ---
    if not os.path.exists(GRANULAR_LOG_PATH):
        print(f"Error: Granular log file not found at '{GRANULAR_LOG_PATH}'.")
        print("Please run the main analysis script first to generate some data.")
        return
    if not os.path.exists(ENGINES_CSV_PATH):
        print(f"Error: Engines CSV file not found at '{ENGINES_CSV_PATH}'.")
        return

    # --- 2. Load and Process Data ---
    try:
        log_df = pd.read_csv(GRANULAR_LOG_PATH)
        engines_df = pd.read_csv(ENGINES_CSV_PATH)
    except pd.errors.EmptyDataError:
        print(f"'{GRANULAR_LOG_PATH}' is empty. No data to analyze yet.")
        return
    except Exception as e:
        print(f"An error occurred while reading the CSV files: {e}")
        return

    if log_df.empty:
        print("Log file is empty. No data to analyze yet.")
        return
        
    print(f"Loaded {len(log_df)} total analyses from the log file.")

    # --- *** NEW: Filter out excluded engines *** ---
    if ENGINES_TO_EXCLUDE:
        print(f"Excluding the following engines: {', '.join(ENGINES_TO_EXCLUDE)}")
        log_df = log_df[~log_df['engine_name'].isin(ENGINES_TO_EXCLUDE)]
        engines_df = engines_df[~engines_df['engine_name'].isin(ENGINES_TO_EXCLUDE)]
        if log_df.empty:
            print("No data left after excluding engines. Cannot proceed.")
            return
    
    # --- 3. Calculate Average Scores ---
    avg_scores_df = log_df.groupby('engine_name')['score'].mean().reset_index()
    avg_scores_df.rename(columns={'score': 'average_hit_score'}, inplace=True)

    # Separate player data from engine data
    player_avg_score_row = avg_scores_df[avg_scores_df['engine_name'] == 'player']
    engine_avg_scores = avg_scores_df[avg_scores_df['engine_name'] != 'player']

    if player_avg_score_row.empty:
        print("No analysis for the player found in the log yet.")
        return
    player_avg_score = player_avg_score_row.iloc[0]['average_hit_score']

    # Merge engine scores with their known ratings
    benchmark_engine_info = engines_df[engines_df['engine_name'] != 'stockfish_full_1']
    final_df = pd.merge(benchmark_engine_info, engine_avg_scores, on='engine_name')

    if len(final_df) < 2:
        print("Not enough benchmark engine data in the log to create a reliable estimate.")
        return

    # --- 4. Perform Linear Regression ---
    # Ensure there's enough variance to calculate a meaningful regression
    if final_df['average_hit_score'].nunique() < 2:
        print("Cannot generate a graph: all benchmark engines have the same average score.")
        return

    slope, intercept, r_value, p_value, std_err = linregress(final_df['average_hit_score'], final_df['rating'])
    r_squared = r_value**2
    
    # Estimate the player's rating
    estimated_player_rating = (slope * player_avg_score) + intercept

    print(f"\n--- Current Overall Status ---")
    print(f"Based on data from {log_df['fen'].nunique()} positions.")
    print(f"Player's Average Hit Score: {player_avg_score:.4f}")
    print(f"Correlation (R-squared): {r_squared:.4f}")
    print(f"Estimated Player Rating: {estimated_player_rating:.0f}")

    # --- 5. Generate Graph ---
    try:
        plt.figure(figsize=(12, 8))
        
        # Plot the regression line with confidence interval
        sns.regplot(
            x='rating', 
            y='average_hit_score', 
            data=final_df, 
            ci=95,  # 95% confidence interval
            line_kws={'color': 'red', 'linestyle': '--'},
            scatter_kws={'s': 80, 'alpha': 0.8}
        )

        # Add a title and labels
        plt.title('Hit Score vs. Engine Rating (Live Progress)', fontsize=16)
        plt.xlabel('Engine Rating (Elo)', fontsize=12)
        plt.ylabel('Average Hit Score', fontsize=12)
        
        # Add the player's point to the graph
        plt.scatter(
            estimated_player_rating, 
            player_avg_score, 
            color='gold', 
            s=200, 
            edgecolor='black', 
            zorder=5, 
            label=f'You ({PLAYER_NAME})'
        )
        plt.text(
            estimated_player_rating + 10, 
            player_avg_score, 
            f'You ({estimated_player_rating:.0f})', 
            fontsize=11, 
            weight='bold'
        )

        # Annotate benchmark engine points
        for _, row in final_df.iterrows():
            plt.text(row['rating'] + 10, row['average_hit_score'], row['engine_name'], fontsize=9)
        
        # Add the R-squared value in a text box
        plt.text(
            0.05, 0.95, f'$R^2 = {r_squared:.4f}$', 
            transform=plt.gca().transAxes, 
            fontsize=14, 
            verticalalignment='top', 
            bbox=dict(boxstyle='round,pad=0.5', fc='wheat', alpha=0.7)
        )
        
        plt.legend()
        plt.grid(True)
        
        # Save the graph
        plt.savefig(OUTPUT_GRAPH_PATH)
        print(f"\nSuccessfully generated live progress graph: '{OUTPUT_GRAPH_PATH}'")

    except Exception as e:
        print(f"\nAn error occurred while creating the graph: {e}")


if __name__ == "__main__":
    analyze_and_graph()
